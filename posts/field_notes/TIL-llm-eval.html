<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-12-26">

<title>TIL from Stanford CME295 Transformers &amp; LLMs | Lecture 8 - LLM Evaluation ‚Äì My Context Window</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-3d62d204ba1604a696ce2d8f1e6896bb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-88291b95e529d21522a5315006bb7b73.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
#quarto-header nav.navbar > .container-fluid{
  padding-left: .75rem;
  padding-right: .75rem;
  max-width: calc(800px + 1.5rem);
  margin: 0 auto;
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Context Window</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">TIL from Stanford CME295 Transformers &amp; LLMs | Lecture 8 - LLM Evaluation</h1>
  <div class="quarto-categories">
    <div class="quarto-category">LLM Evaluation</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 26, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Output quality - instruction following - coherence - factuality</p>
<p>System performance - latency - cost - reliability</p>
<ul>
<li>human ratings are gold standard.
<ul>
<li>Subjectivity of human ratings -&gt; agreement rate = <span class="math inline">\(p_{o}\)</span> -&gt; o stands for observed
<ul>
<li>‚ÄúHow much better is our agreement than what we‚Äôd expect just by chance, given how the raters actually use the categories?‚Äù ‚ÄúA coefficient of agreement for nominal scales‚Äù, Cohen, 1960, ‚ÄúMeasuring nominal scale agreement among many raters‚Äù, Fleiss, 1971.</li>
<li>Variants. Cohen‚Äôs Kappa, Fleiss‚Äô Kappa, Krippendorff‚Äôs alpha</li>
</ul></li>
<li>human ratings are slow and expensive</li>
</ul></li>
<li>rule-based metrics
<ul>
<li>METEOR. Metric for Evaluation of Translation with Explicit ORdering
<ul>
<li>write labels once, use as reference</li>
</ul></li>
<li>BLEU (BiLingual Evaluation Understudy)</li>
<li>ROUGE (Recall-Oriented Understudy for Gisting Evaluation)
<ul>
<li>Many variants (ROUGE-N, ROUGE-L, etc.) with suite of metrics</li>
</ul></li>
<li>Problem with rule-based:
<ul>
<li>Does not take into account stylistic variations</li>
<li>Correlation with human rating is not that great</li>
<li>still requires human ratings</li>
</ul></li>
</ul></li>
<li>LLM-as-a-Judge
<ul>
<li>Use LLM to rate quality of response.</li>
<li>&lt;prompt, model-response, criteria&gt; -&gt; &lt;score (pass/fail), reason&gt;</li>
<li>Structured Outputs (in practice)</li>
<li>Benefit: No need for reference / label; Interpretability via rationales</li>
<li>Variations: Point-wise or Pair-wise (A or B is better)
<ul>
<li>Position A - position bias
<ul>
<li>Remedy. ‚ÄúTake the average‚Äù, or tweak position embeddings</li>
</ul></li>
<li>Verbosity bias
<ul>
<li>Remedy. Explicit guidelines, few-shot, and/or penalty on output length</li>
</ul></li>
<li>Self-enhancement bias
<ul>
<li>Remedy, Don‚Äôt use agent as judge</li>
</ul></li>
</ul></li>
<li>Best pracitices
<ul>
<li>crisp guidelines</li>
<li>binary scale over granular ones</li>
<li>write rationaile before outputting score (autoregressive)</li>
<li>mitigate biases (position, verbosity, self-enhancement)</li>
<li>calibrate with human judgements</li>
<li>low temperature for reproducibility</li>
</ul></li>
</ul></li>
<li>Typical things we want to evaluate for
<ul>
<li>task performance
<ul>
<li>Usefulness</li>
<li>Factuality</li>
<li>Relevance</li>
</ul></li>
<li>alignment
<ul>
<li>tone</li>
<li>style</li>
<li>safety</li>
</ul></li>
</ul></li>
<li>Factuality
<ul>
<li>quantify factuality - president roosevelt and teddy example</li>
<li>decompose into various facts and do weighted average</li>
</ul></li>
<li>ReAct
<ul>
<li>Tool prediction error
<ul>
<li>LLM directly issues reposnse -&gt; tool router error -&gt; retrain tool router</li>
<li>LLM directly issues response -&gt; tool found but model doesn‚Äôt know how to use it -&gt; SFT train model or better adjust prompt associated to target API</li>
<li>hallucinates tool? -&gt; llm using tool that doesn‚Äôt exist -&gt; perhaps model too weak -&gt; upgrade model
<ul>
<li>or API naming is not logical -&gt; revamp API</li>
<li>or instructions are unclear -&gt; revamp top-level instructions</li>
</ul></li>
<li>LLM uses wrong tool
<ul>
<li>tool router error -&gt; retrain tool router</li>
<li>model chose wrong tool -&gt; SFT train or better adjust prompt associated to target API</li>
</ul></li>
<li>Infers wrong argument:
<ul>
<li>argument can‚Äôt be inferred -&gt; Introduce a helper tool and/or ensure the context carries the right information</li>
<li>Model doesn‚Äôt know how to use the tool -&gt; SFT train or better adjust prompt associated to target API<br>
</li>
</ul></li>
</ul></li>
<li>Tool call errors
<ul>
<li>wrong response or error returned
<ul>
<li>sometimes, errors are legitimitate</li>
<li>otherwise, fix the tool implementation</li>
</ul></li>
<li>no response
<ul>
<li>when final response is hallucinated, we often see this</li>
<li>Return something, even if it‚Äôs an empty JSON; in general, return meaningful tool outputs</li>
</ul></li>
</ul></li>
<li>Response generation error: wrong response
<ul>
<li>Final response doesn‚Äôt convey the tool‚Äôs response
<ul>
<li>model lacks grounding capabilities - upgrade LLM</li>
<li>Tool response spams the context window - Trim/summarize information returned by the backend</li>
<li>Tool response does not convey information meaningfully - Make the tool output format descriptive</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p>Summary<br>
- Failures: does not use/hallucinates/uses the wrong tool, infers wrong argument - Failures: wrong response, no response (tool impl.) - Failure: wrong response (generation)</p>
<p>Modeling - Weak reasoning, grounding capabilities - Too much going on in the context window - Tool modeling isn‚Äôt right Tool - Tool itself has a problem - Output of the tool isn‚Äôt interpretable</p>
<p>Common benchmarks - MMLU for knowledge - Massive Multitask Language Understanding - MCQ ‚Ä¢ Accurately state facts about the world ‚Ä¢ More ‚Äúbreadth‚Äù than ‚Äúdepth‚Äù ‚Ä¢ Reflects pretraining quality</p>
<ul>
<li>Reasoning benchmarks
<ul>
<li>AIME (American Invitational Mathematics Examination)
<ul>
<li>output correct answer on ~30 math problems Geometry, Algebra, Analysis</li>
</ul></li>
<li>PIQA (Physical Interaction: Question Answering )
<ul>
<li>Characteristics. 2 possible choices per question on everyday situations anchored in Physics. Has approximately 20,000 examples. Evaluation criteria. Find the right choice among Sol1/Sol2.</li>
</ul></li>
</ul></li>
<li>Coding
<ul>
<li>SWE bench (SoftWare Engineering benchmark)
<ul>
<li>‚Ä¢ Generate syntactically correct code ‚Ä¢ Tests for programming proficiency ‚Ä¢ Proxy for tool use abilities</li>
</ul></li>
</ul></li>
</ul>
<p>Characteristics. 2,294 software engineering problems from real GitHub issues across 12 popular Python repositories. Each problem has: ‚óè a base commit ‚óè an already merged PR with tests</p>
<p>Evaluation criteria. Generated PR passes all test cases.</p>
<ul>
<li><p>Safety</p></li>
<li><p>Prevent harmful, toxic, inappropriate behavior ‚Ä¢ Surfaces vulnerabilities before deployment ‚Ä¢ Alignment with custom preferences</p></li>
<li><p>HarmBench (Harmful Behavior Benchmark) Characteristics. 510 unique harmful behaviors (400 text-based, 110 multimodal) split into: ‚óè ‚ÄúStandard‚Äù ‚óè ‚ÄúCopyright‚Äù ‚óè ‚ÄúContextual‚Äù ‚óè ‚ÄúMultimodal‚Äù Criteria: violate laws and widely-held norms Evaluation criteria. Attack success rate (ASR).</p></li>
<li><p>classifier as output</p></li>
<li><p>there are both contextual as well as multi-modal behaviors</p></li>
<li><p>Agents</p>
<ul>
<li>ùúè-bench = Tool-Agent-User Interaction Benchmark</li>
<li>Characteristics. A given set of database schema, APIs and policies across 2 domains: ‚óè Airline agent ‚óã 500 users, 300 flights, 2000 reservations ‚óã ~10 tools and 50 tasks ‚óè Retail agent ‚óã 500 users, 50 products, 1000 orders ‚óã ~10 tools and 115 tasks Evaluation criteria. Maximize reward and pass^k</li>
</ul></li>
<li><p>Pass^k = ‚ÄúProbability that all k attempts succeed‚Äù</p></li>
</ul>
<p>Role of benchmarks. ‚óè A projection of performance across a given axis ‚óè Different models may be good at different things</p>
<p>Definition. Pareto curve = set of solutions that ‚Äúoptimizes‚Äù a trade-off. https://winston-bosan.github.io/llm-pareto-frontier/</p>
<p>Possible trade-offs. ‚óè quality vs.&nbsp;cost/latency ‚óè quality vs.&nbsp;safety ‚óè quality vs.&nbsp;context length</p>
<hr>
<p>Beware of data contamination Problem. Benchmark‚Äôs clues may be contained in the training set</p>
<p>Precautions. ‚óè Use an identifier such as a hash ‚óè For tools, use a blocklist ‚óè Evaluate on newer test versions!</p>
<p>Lessons. ‚óè Should not over-index on benchmarks ‚óè Need for ~organic perspectives to complete the picture: Chatbot Arena ‚óè ‚Ä¶just try a few models out yourself!</p>
<blockquote class="blockquote">
<p><strong>Licensing Notice</strong>: Text and media: <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>; Code: <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></p>
</blockquote>



</main> <!-- /main -->
<script>
    document.addEventListener("DOMContentLoaded", function () {
        if (window.location.pathname.includes("/posts/")) {
            var repoUrl = "https://github.com/shivam-miglani/genai-blog/blob/main";
            var path = window.location.pathname;

            // Remove deployment path prefix (e.g. /genai-blog/) if present
            // We assume the structure is .../posts/...
            var parts = path.split("/posts/");
            if (parts.length > 1) {
                var relativePath = parts[1];

                if (relativePath.endsWith("/") || relativePath === "") {
                    relativePath += "index.qmd";
                } else if (relativePath.endsWith(".html")) {
                    relativePath = relativePath.replace(".html", ".ipynb");
                }

                var gitHubUrl = repoUrl + "/posts/" + relativePath;

                var footer = document.createElement("div");
                footer.style.marginTop = "3rem";
                footer.style.paddingTop = "1rem";
                footer.style.borderTop = "1px solid #e9ecef";
                footer.style.textAlign = "center";
                footer.style.fontSize = "0.8em";
                footer.innerHTML = "<a href='" + gitHubUrl + "' target='_blank' style='color: inherit; text-decoration: none; font-weight: bold;'>View source on <i class='bi bi-github'></i></a>";

                var main = document.querySelector("main");
                if (main) {
                    main.appendChild(footer);
                }
            }
        }
    });
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shivam-miglani\.github\.io\/genai-blog\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><a href="../../about.html">About</a> ¬∑ ¬© 2025 Shivam Miglani</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>